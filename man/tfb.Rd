% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tfb.R
\name{tfb}
\alias{tfb}
\title{Targeted Function Balancing}
\usage{
tfb(
  X,
  d,
  y,
  fit,
  estimand,
  quiet = T,
  folds = 2,
  samples = 1,
  bstrap_cov = F,
  ...
)
}
\arguments{
\item{X}{The covariate dataset, containing all observed confounders of the relationship between the treatment and the outcome. \code{X} can contain categorical covariates if a dataframe is supplied. A categorical covariate with \code{n} levels will be converted to \code{n-1} indicator variables for \code{tfb}'s optimization. A numeric matrix or a dataframe. No default.}

\item{d}{The dichotomous treatment vector, which takes the value of \code{0} or \code{FALSE} when an observation is in the control group, and the value of \code{1} or \code{TRUE} when an observation is in the treatment group. If a dichotomous character vector is supplied, the first value in the vector will be interpreted as indicating treatment. A numeric, logical, or character vector. No default.}

\item{y}{The outcome vector, containing the measured response for each observation. A numeric vector. No default.}

\item{fit}{The hypothesized functional form of the relationship between the outcome and the covariates. This decides what regression model will be fit on the data and targeted by the targeted function balancing. Can be set to one or two of the following:
\itemize{
\item \code{"ols"}: ordinary least squares ( \code{lm()} ) will be used.
\item \code{"krls"}: kernel regularized least squares ( \code{krls()} ) will be used.
\item \code{"elasticnet"}: an elastic net penalized regression ( \code{glmnet()} ) will be used.
}

\code{fit} should only include two values when estimating the ATE and the treatment and control potential outcomes are hypothesized to be produced by different families of functions on the covariates. A character or character vector. No default.}

\item{estimand}{The causal inference estimand to be estimated via targeted function balancing. Can be set to one of the following:
\itemize{
\item \code{"att"}: the average treatment effect on the treated (ATT) will be estimated.
\item \code{"atc"}: the average treatment effect on the controlled (ATC) will be estimated.
\item \code{"ate"}: the average treatment effect (ATE) will be estimated.
}

A character. No default.}

\item{quiet}{If set to \code{TRUE}, suppresses console output. A logical. Default is \code{TRUE}.}

\item{folds}{The number of folds for cross-fitting. The data will be partitioned uniformly at random into this many folds. It is suggested to use at least two folds, as using only one makes cross-fitting impossible and may introduce bias. An integer. Default is \code{2}.}

\item{samples}{The number of times to sample the data; the number of times the data is split into folds. An integer. Default is \code{1}.}

\item{bstrap_cov}{Whether to bootsrap the covariance. If \code{FALSE}, \code{tfb} will estimate the covariance matrix via closed formula where applicable. \code{bstrap_cov} is ignored when there is no closed form for the covariance matrix (elasticnet). Setting this to \code{TRUE} may significantly extend calculation times. A logical. Default is \code{FALSE}.}

\item{...}{Additional named arguments. See \emph{Details} for more information.}
}
\value{
A nested list:
\itemize{
\item \code{final}: Summary statistics and estimates for the dataset, including:
\item \code{sample_i}: Summary statistics for the ith sample, including:
}

Containing generally:
\itemize{
\item \code{estimate}: The TFB estimate/weighted difference in means.
\item \code{variance}: The variance of the estimate.
\item \code{confidence_interval}: The confidence interval for the estimate.
\item \code{p_value}: The p-value for the estimate under the null hypothesis that there is no treatment effect.
\item \code{dim}: The unweighted difference in means.
}

Containing by sample:
\itemize{
\item \code{weights}: TFB's weights.
}

Containing by fold:
\itemize{
\item \code{indices}: The fold indices.
\item \code{betas}: The covariate coefficients for the targeted function.
\item \code{covariances}: The covariance matrices for the targeted function.
\item \code{errors}: The residuals within the fold.
\item \code{standard_errors}: The variance estimates of error terms within the regression.
\item \code{dims}: The unweighted differences in means.
\item \code{estimates}: The TFB estimates/weighted differences in means.
\item \code{variances}: The variances of the estimates.
}
}
\description{
\code{tfb} performs Targeted Function Balancing, a weighting method for causal inference. \code{tfb} weights observations in your dataset by minimizing targeted function imbalance from an initial regression, and returns a causal estimate as well as summary statistics. \code{tfb} is intended for use with data from observational studies where inference about the effect of a treatment is desired even though the treatment assignment mechanism is unknown or dependent on the covariates.
}
\details{
The dynamic dots also allow for a number of additional, more technical parameters:
\itemize{
\item \code{bstrap_reps}: How many times to bootstrap the covariance matrix. This will have a significant effect on computation time, especially when targeting KRLS, as the reparametrization of X to its kernel matrix K greatly increases the number of covariates, provided n >> p. An integer. Default is \code{400.}
\item \code{confidence}: The choice of confidence level for the reported confidence intervals. A double. Default is \code{0.95}.
\item \code{chi_q}: The choice of quantile for the chi-squared distribution, which effectively controls the spread of the hypothesized distribution of \eqn{\hat\beta_d} about the true coefficient vector \eqn{\beta_d} in \eqn{\mathbb{R}^n}, supposing the CEF has been correctly specified. \code{chi_q} is used to specify the squidward constant. A double. Default is \code{0.95}.
\item \code{ev_approx}: Whether to abbreviate calculation of covariance matrices using \code{RSpectra}, for when computation of the covariance matrix would be particularly taxing (large p). A logical. Default is \code{False.}
\item \code{ev_n}: How many eigenpairs \code{RSpectra} should calculate. The user is recommended to analyze a complete sample eigenmatrix first, to look for a common breakpoint such that the calculated eigenvalues still account for most all of the total explained variance. If the number is too big with KRLS a full decomposition will be performed instead. An integer. The default is typically \code{5}.
\item \code{kernelfn}: A way to specify the inner product kernel function alternative to the KRLS default (the gaussian kernel). \code{tfb} has to restandardize all of the KRLS kernel matrices in order for calculations to turn out correctly, but this requires the use of the correct inner product. In short, if the user passes KRLS an alternative \code{whichkernel} through the dynamic dots, they must also pass \code{tfb} an inner product matching the alternative kernel, taking two rows of the covariate matrix as input and returning a positive semidefinite similarity score as output. A function. The default is the gaussian kernel, which the user may wish to view as a template: \code{tfb:::tfb_kernelfn}.
\item \code{reg_d}: Whether to incorporate the treatment vector into the covariates, allowing it to be used for prediction in the targeting stage of \code{tfb}. \eqn{\hat f_0} and \eqn{\hat f_1} are then respectively calculated by forcing \eqn{D} to be a constant term of zero for \eqn{\hat f_0} and one for \eqn{\hat f_1}. This also implies that \code{tfb} will train \eqn{\hat f_0} and \eqn{\hat f_1} on both treatment and control units. A logical. The default is \code{False}.
\item \code{X_c},\code{X_t}: A way to modify training data for \eqn{\hat f_0} and \eqn{\hat f_1} \emph{separately} of the rest of the dataset. For example, you could fit an \eqn{\hat f_0 = \beta_0+\beta_1x_1+\beta_2x_2^2} by letting \code{X_c = cbind(X[, 1],X[, 2]^2)} while leaving \eqn{\hat f_1 = \beta_0 + \beta_1x_1+\beta_2x_2}. Numeric matrices. Default is \code{X}.
}
}
\examples{

X <- iris[, 2:4]
d <- iris[, 5] == "setosa"
y <- iris[, 1]
# estimating the effect of `Species == "setosa"` on `Sepal.Length`
# given `Sepal.Width`, `Petal.Length`, and `Petal.Width`
tfb(X, d, y, fit = "ols", estimand = "att")$final$estimate

}
\keyword{tfb}
